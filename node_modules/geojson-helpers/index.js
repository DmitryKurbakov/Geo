"use strict";
const path_1 = require('path');
const fs = require('fs');
/**
 * Writes GeoJSON file
 *
 * @param {string} path
 * @param {FeatureCollection} geojson GeoJSON FeatureCollection
 * @param {Array<string|number>} [properties] Only include the following properties
 */
function writeFileSync(path, geojson, properties) {
    mkdir(path);
    const stream = fs.createWriteStream(path);
    writeHeader(stream);
    geojson.features.map((feature, index, array) => {
        if (properties !== undefined) {
            feature.properties = pick(feature.properties, properties);
        }
        feature.geometry.coordinates = toFix(feature.geometry.coordinates);
        feature = removeEmptyProperties(feature);
        writeFeature(stream, feature, index, array);
    });
    writeFooter(stream);
}
exports.writeFileSync = writeFileSync;
/**
 * Remove Empty values
 *
 * @param {GeoJSON.Feature<any>} feature
 */
function removeEmptyProperties(feature) {
    const properties = {};
    Object.keys(feature.properties).map(key => {
        const value = feature.properties[key];
        if (value !== undefined && value !== '') {
            properties[key] = value;
        }
    });
    feature.properties = properties;
    return feature;
}
exports.removeEmptyProperties = removeEmptyProperties;
/**
 * Reads GeoJSON file
 *
 * @param {string} path File must be a GeoJSON FeatureCollection
 */
function readFileSync(path) {
    return JSON.parse(fs.readFileSync(path, 'utf-8'));
}
exports.readFileSync = readFileSync;
function mkdir(path) {
    const folder = path_1.dirname(path_1.resolve(path));
    if (!fs.existsSync(folder)) {
        fs.mkdirSync(folder);
    }
}
function writeHeader(stream) {
    stream.write('{\n');
    stream.write('"type": "FeatureCollection",\n');
    stream.write('"features": [\n');
}
function writeFooter(stream) {
    stream.write(']\n}\n');
}
function writeFeatureEnd(stream, index, array) {
    if (index + 1 !== array.length) {
        stream.write(',\n');
    }
    else {
        stream.write('\n');
    }
}
function toFix(array) {
    return array.map(value => {
        if (typeof (value) === 'object') {
            return toFix(value);
        }
        return Number(value.toFixed(6));
    });
}
function pick(object, keys) {
    const container = {};
    Object.keys(object).map(key => {
        if (keys.indexOf(key) !== -1) {
            container[key] = object[key];
        }
    });
    return container;
}
function writeFeature(stream, feature, index, array) {
    stream.write(JSON.stringify(feature));
    writeFeatureEnd(stream, index, array);
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    readFileSync,
    writeFileSync,
};
//# sourceMappingURL=index.js.map